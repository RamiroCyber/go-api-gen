package {{.ModuleName}}

import (
    "errors"
    "fmt"
    "github.com/gofiber/fiber/v2"
    "github.com/google/uuid"
    "strconv" // Novo: para parsear ints de query params
)

type {{.TitleModuleName}}Controller struct {
    service {{.TitleModuleName}}Service
}

func New{{.TitleModuleName}}Controller(service {{.TitleModuleName}}Service) *{{.TitleModuleName}}Controller {
    return &{{.TitleModuleName}}Controller{service: service}
}

func (ctrl *{{.TitleModuleName}}Controller) Create(c *fiber.Ctx) error {
    var entity {{.TitleModuleName}}
    if err := c.BodyParser(&entity); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": fmt.Sprintf("failed to parse request body: %v", err)})
    }
    // Opcional: Use um DTO separado para request se quiser decoupling (ex: sem ID no body)
    if err := ctrl.service.Create(c.Context(), &entity); err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to create entity: %v", err)})
    }
    return c.Status(fiber.StatusCreated).JSON(entity)
}

func (ctrl *{{.TitleModuleName}}Controller) Read(c *fiber.Ctx) error {
    idStr := c.Params("id")
    id, err := uuid.Parse(idStr)
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid ID format"})
    }
    entity, err := ctrl.service.Read(c.Context(), id)
    if err != nil {
        if errors.Is(err, errors.New("entity not found")) { // Ajuste para errors.Is se usar erros customizados
            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "entity not found"})
        }
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to read entity: %v", err)})
    }
    return c.Status(fiber.StatusOK).JSON(entity)
}

func (ctrl *{{.TitleModuleName}}Controller) Update(c *fiber.Ctx) error {
    idStr := c.Params("id")
    id, err := uuid.Parse(idStr)
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid ID format"})
    }

    var entity {{.TitleModuleName}}
    if err := c.BodyParser(&entity); err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": fmt.Sprintf("failed to parse request body: %v", err)})
    }
    // Verifique se ID no body combina com param (segurança)
    if entity.ID != uuid.Nil && entity.ID != id {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "ID in body does not match path parameter"})
    }
    entity.ID = id // Defina ID do param se não fornecido no body

    // Para updates parciais, considere PATCH e um DTO com campos opcionais (ex: using pointers or json omitempty)
    if err := ctrl.service.Update(c.Context(), &entity); err != nil {
        if errors.Is(err, errors.New("entity not found")) { // Ajuste para errors.Is se usar erros customizados
            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "entity not found"})
        }
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to update entity: %v", err)})
    }
    return c.Status(fiber.StatusOK).JSON(entity)
}

func (ctrl *{{.TitleModuleName}}Controller) Delete(c *fiber.Ctx) error {
    idStr := c.Params("id")
    id, err := uuid.Parse(idStr)
    if err != nil {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid ID format"})
    }
    if err := ctrl.service.Delete(c.Context(), id); err != nil {
        if errors.Is(err, errors.New("entity not found")) { // Ajuste para errors.Is se usar erros customizados
            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "entity not found"})
        }
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to delete entity: %v", err)})
    }
    return c.SendStatus(fiber.StatusNoContent)
}

func (ctrl *{{.TitleModuleName}}Controller) List(c *fiber.Ctx) error {
    // Parse query params para paginação (com defaults)
    pageStr := c.Query("page", "1")
    limitStr := c.Query("limit", "10")
    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }
    limit, err := strconv.Atoi(limitStr)
    if err != nil || limit < 1 {
        limit = 10
    }

    // Adicione suporte a filtros extras via query params se necessário (ex: ?search=term)
    entities, total, err := ctrl.service.List(c.Context(), page, limit)
    if err != nil {
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to list entities: %v", err)})
    }

    // Retorne com metadados de paginação
    return c.Status(fiber.StatusOK).JSON(fiber.Map{
        "data":  entities,
        "total": total,
        "page":  page,
        "limit": limit,
    })
}

{{range .CustomMethods}}
func (ctrl *{{$.TitleModuleName}}Controller) {{.}}(c *fiber.Ctx) error {
    param := c.Query("param")  // Placeholder: Ajuste para body, path params ou múltiplos queries conforme método (ex: c.Params("email") para FindByEmail/:email)
    if param == "" {
        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "missing required parameter"})
    }
    entity, err := ctrl.service.{{.}}(c.Context(), param)
    if err != nil {
        if errors.Is(err, errors.New("entity not found")) { // Ajuste para errors.Is se usar erros customizados
            return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "entity not found"})
        }
        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("failed to {{.}}: %v", err)})
    }
    return c.Status(fiber.StatusOK).JSON(entity)
}
{{end}}